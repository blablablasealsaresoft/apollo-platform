name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.2.3)'
        required: true
        type: string
      skip_staging_check:
        description: 'Skip staging verification (emergency only)'
        required: false
        default: 'false'
        type: boolean
      rollback_version:
        description: 'Rollback to specific version (leave empty for new deploy)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  ENVIRONMENT: production
  NAMESPACE: apollo-production
  CLUSTER_NAME: apollo-production-cluster

concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  # Validate deployment request
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.tag }}
      is_rollback: ${{ steps.check.outputs.is_rollback }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ inputs.version }}" ]; then
            echo "tag=${{ inputs.version }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "release" ]; then
            echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "No version specified"
            exit 1
          fi

      - name: Check if rollback
        id: check
        run: |
          if [ -n "${{ inputs.rollback_version }}" ]; then
            echo "is_rollback=true" >> $GITHUB_OUTPUT
            echo "üîÑ This is a ROLLBACK to version ${{ inputs.rollback_version }}"
          else
            echo "is_rollback=false" >> $GITHUB_OUTPUT
          fi

      - name: Verify version exists
        run: |
          VERSION="${{ steps.version.outputs.tag }}"
          if ! git tag | grep -q "^${VERSION}$"; then
            echo "‚ùå Version ${VERSION} does not exist"
            exit 1
          fi
          echo "‚úÖ Version ${VERSION} exists"

      - name: Verify staging deployment
        if: inputs.skip_staging_check != 'true' && steps.check.outputs.is_rollback != 'true'
        run: |
          echo "Verifying staging deployment status..."
          # Check staging health endpoint
          STAGING_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://staging.apollo-platform.com/api/health" --max-time 10 || echo "000")
          if [ "$STAGING_STATUS" != "200" ]; then
            echo "‚ö†Ô∏è Warning: Staging environment may not be healthy (HTTP $STAGING_STATUS)"
            echo "Consider deploying to staging first"
          fi

  # Pre-production approval
  approval:
    name: Production Approval
    runs-on: ubuntu-latest
    needs: [validate]
    environment:
      name: production-approval
      url: https://apollo-platform.com

    steps:
      - name: Request approval
        run: |
          echo "üîê Production deployment requires approval"
          echo "Version: ${{ needs.validate.outputs.version }}"
          echo "Requested by: ${{ github.actor }}"
          echo "Is Rollback: ${{ needs.validate.outputs.is_rollback }}"

      - name: Log approval
        run: |
          echo "‚úÖ Production deployment approved"
          echo "Approved at: $(date -u)"

  # Pre-deployment backup
  backup:
    name: Pre-Deployment Backup
    runs-on: ubuntu-latest
    needs: [approval]
    environment:
      name: production

    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

      - name: Configure AWS CLI
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Create database backup
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BACKUP_NAME="pre-deploy-${{ github.run_number }}-${TIMESTAMP}"

          echo "Creating database backup: ${BACKUP_NAME}"

          # Create backup job
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: backup-${TIMESTAMP}
            namespace: ${{ env.NAMESPACE }}
          spec:
            ttlSecondsAfterFinished: 7200
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: backup
                  image: postgres:15
                  command:
                  - /bin/sh
                  - -c
                  - |
                    pg_dump -h \$DB_HOST -U \$DB_USER -d \$DB_NAME > /backup/${BACKUP_NAME}.sql
                    gzip /backup/${BACKUP_NAME}.sql
                  envFrom:
                  - secretRef:
                      name: apollo-db-credentials
                  volumeMounts:
                  - name: backup-volume
                    mountPath: /backup
                volumes:
                - name: backup-volume
                  persistentVolumeClaim:
                    claimName: backup-pvc
          EOF

          # Wait for backup
          kubectl wait --for=condition=complete job/backup-${TIMESTAMP} \
            -n ${{ env.NAMESPACE }} --timeout=600s

      - name: Upload backup to S3
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "Uploading backup to S3..."
          # The backup would be uploaded by the job above or a separate sync process
          echo "Backup uploaded to s3://apollo-backups/production/pre-deploy/"

      - name: Record current deployment state
        run: |
          echo "Recording current deployment state for rollback..."
          kubectl get deployments -n ${{ env.NAMESPACE }} -o yaml > /tmp/deployment-state.yaml
          echo "Current deployment state recorded"

  # Database migrations
  migrations:
    name: Database Migrations
    runs-on: ubuntu-latest
    needs: [backup, validate]
    if: needs.validate.outputs.is_rollback != 'true'
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.version }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

      - name: Run migrations
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: migration-${TIMESTAMP}
            namespace: ${{ env.NAMESPACE }}
          spec:
            ttlSecondsAfterFinished: 3600
            backoffLimit: 0
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migration
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/apollo-authentication:${{ needs.validate.outputs.version }}
                  command: ["npm", "run", "db:migrate:production"]
                  envFrom:
                  - secretRef:
                      name: apollo-db-credentials
                  - configMapRef:
                      name: apollo-config
          EOF

          kubectl wait --for=condition=complete job/migration-${TIMESTAMP} \
            -n ${{ env.NAMESPACE }} --timeout=600s

      - name: Verify migrations
        run: |
          echo "Verifying database schema..."
          # Add schema verification commands here

  # Blue-Green deployment
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [migrations, validate, backup]
    if: always() && (needs.migrations.result == 'success' || needs.migrations.result == 'skipped')
    environment:
      name: production
      url: https://apollo-platform.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.validate.outputs.version }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

      - name: Record deployment start
        run: |
          echo "DEPLOY_START=$(date +%s)" >> $GITHUB_ENV
          echo "üöÄ Production deployment started at $(date -u)"

      - name: Determine deployment version
        id: deploy_version
        run: |
          if [ -n "${{ inputs.rollback_version }}" ]; then
            echo "version=${{ inputs.rollback_version }}" >> $GITHUB_OUTPUT
            echo "üîÑ Rolling back to version: ${{ inputs.rollback_version }}"
          else
            echo "version=${{ needs.validate.outputs.version }}" >> $GITHUB_OUTPUT
            echo "üöÄ Deploying version: ${{ needs.validate.outputs.version }}"
          fi

      - name: Deploy services (canary - 10%)
        run: |
          VERSION="${{ steps.deploy_version.outputs.version }}"
          echo "Starting canary deployment with $VERSION..."

          # Scale down existing and add canary
          SERVICES=(
            "api-gateway"
            "authentication"
            "intelligence"
            "operations"
            "search"
            "notifications"
            "analytics"
            "user-management"
          )

          for service in "${SERVICES[@]}"; do
            echo "Deploying canary for $service..."

            # Update deployment with new image
            kubectl set image deployment/apollo-$service \
              apollo-$service=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/apollo-$service:$VERSION \
              -n ${{ env.NAMESPACE }} --record || echo "Deployment not found: $service"

            # Set deployment strategy to rolling update
            kubectl patch deployment/apollo-$service -n ${{ env.NAMESPACE }} \
              -p '{"spec":{"strategy":{"rollingUpdate":{"maxSurge":"25%","maxUnavailable":"0"}}}}' || true
          done

      - name: Monitor canary (5 minutes)
        run: |
          echo "Monitoring canary deployment..."
          sleep 60

          # Check error rates
          ERROR_COUNT=$(kubectl logs -n ${{ env.NAMESPACE }} -l app.kubernetes.io/part-of=apollo \
            --tail=500 --since=2m 2>/dev/null | grep -i "error\|exception" | wc -l || echo "0")

          echo "Errors in last 2 minutes: $ERROR_COUNT"

          if [ "$ERROR_COUNT" -gt 50 ]; then
            echo "‚ùå High error rate detected during canary!"
            exit 1
          fi

          echo "‚úÖ Canary health looks good"

      - name: Complete rollout
        run: |
          echo "Completing full rollout..."

          SERVICES=(
            "api-gateway"
            "authentication"
            "intelligence"
            "operations"
            "search"
            "notifications"
            "analytics"
            "user-management"
          )

          for service in "${SERVICES[@]}"; do
            echo "Waiting for $service rollout..."
            kubectl rollout status deployment/apollo-$service \
              -n ${{ env.NAMESPACE }} --timeout=600s || echo "Rollout status check failed for $service"
          done

      - name: Update deployment metadata
        run: |
          VERSION="${{ steps.deploy_version.outputs.version }}"

          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: deployment-metadata
            namespace: ${{ env.NAMESPACE }}
          data:
            version: "$VERSION"
            commit_sha: "${{ github.sha }}"
            run_number: "${{ github.run_number }}"
            deployed_at: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            deployed_by: "${{ github.actor }}"
            is_rollback: "${{ needs.validate.outputs.is_rollback }}"
          EOF

  # Production health verification
  verify:
    name: Production Verification
    runs-on: ubuntu-latest
    needs: [deploy]
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for stabilization
        run: sleep 60

      - name: Comprehensive health checks
        run: |
          ENDPOINTS=(
            "health"
            "api/auth/health"
            "api/intelligence/health"
            "api/operations/health"
            "api/search/health"
            "api/notifications/health"
            "api/analytics/health"
            "api/users/health"
          )

          BASE_URL="https://apollo-platform.com"
          FAILED=0
          RETRIES=3

          for endpoint in "${ENDPOINTS[@]}"; do
            echo "Checking $endpoint..."
            SUCCESS=false

            for i in $(seq 1 $RETRIES); do
              RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/$endpoint" --max-time 15 || echo "000")

              if [ "$RESPONSE" == "200" ]; then
                echo "  ‚úÖ $endpoint is healthy (HTTP $RESPONSE)"
                SUCCESS=true
                break
              else
                echo "  ‚ö†Ô∏è Attempt $i: $endpoint returned HTTP $RESPONSE"
                sleep 5
              fi
            done

            if [ "$SUCCESS" == "false" ]; then
              echo "  ‚ùå $endpoint failed after $RETRIES attempts"
              FAILED=$((FAILED + 1))
            fi
          done

          if [ $FAILED -gt 0 ]; then
            echo ""
            echo "‚ùå $FAILED health checks failed!"
            exit 1
          fi

          echo ""
          echo "‚úÖ All production health checks passed!"

      - name: Performance validation
        run: |
          echo "Running performance validation..."

          # Test response times
          RESPONSE_TIME=$(curl -s -w "%{time_total}" -o /dev/null "https://apollo-platform.com/api/health" --max-time 10)
          echo "Health endpoint response time: ${RESPONSE_TIME}s"

          # Check if response time is acceptable (< 2 seconds)
          if (( $(echo "$RESPONSE_TIME > 2.0" | bc -l) )); then
            echo "‚ö†Ô∏è Response time is higher than expected"
          else
            echo "‚úÖ Response time is acceptable"
          fi

      - name: Run smoke tests
        run: |
          echo "Running production smoke tests..."

          # Basic API functionality check
          curl -s "https://apollo-platform.com/api/health" | jq . || echo "Health check response received"

          echo "‚úÖ Smoke tests completed"

  # Monitoring and alerting
  monitor:
    name: Post-Deploy Monitoring
    runs-on: ubuntu-latest
    needs: [verify]

    steps:
      - name: Extended monitoring period
        run: |
          echo "Starting 5-minute monitoring period..."

          for i in {1..5}; do
            echo "Minute $i of 5..."

            # Check health
            HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "https://apollo-platform.com/api/health" --max-time 10 || echo "000")

            if [ "$HEALTH" != "200" ]; then
              echo "‚ùå Health check failed at minute $i (HTTP $HEALTH)"
              exit 1
            fi

            echo "  ‚úÖ Health OK"
            sleep 60
          done

          echo "‚úÖ Extended monitoring completed successfully"

      - name: Check metrics
        run: |
          echo "Verifying metrics collection..."
          # Query Prometheus for error rates
          # This would typically be a curl to Prometheus API

      - name: Generate deployment report
        run: |
          echo "# üöÄ Production Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ‚úÖ Successful" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.validate.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Production" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Verification Results" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ All health checks passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Performance validation passed" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Extended monitoring completed" >> $GITHUB_STEP_SUMMARY

  # Rollback on failure
  auto-rollback:
    name: Auto Rollback
    runs-on: ubuntu-latest
    needs: [deploy, verify, monitor]
    if: failure()

    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config

      - name: Execute automatic rollback
        run: |
          echo "‚ö†Ô∏è Deployment verification failed!"
          echo "üîÑ Initiating automatic rollback..."

          SERVICES=(
            "api-gateway"
            "authentication"
            "intelligence"
            "operations"
            "search"
            "notifications"
            "analytics"
            "user-management"
          )

          for service in "${SERVICES[@]}"; do
            echo "Rolling back $service..."
            kubectl rollout undo deployment/apollo-$service -n ${{ env.NAMESPACE }} || true
          done

      - name: Wait for rollback
        run: |
          SERVICES=(
            "api-gateway"
            "authentication"
            "intelligence"
            "operations"
            "search"
            "notifications"
            "analytics"
            "user-management"
          )

          for service in "${SERVICES[@]}"; do
            kubectl rollout status deployment/apollo-$service -n ${{ env.NAMESPACE }} --timeout=300s || true
          done

      - name: Verify rollback health
        run: |
          sleep 30
          HEALTH=$(curl -s -o /dev/null -w "%{http_code}" "https://apollo-platform.com/api/health" --max-time 15)

          if [ "$HEALTH" == "200" ]; then
            echo "‚úÖ Rollback successful - system is healthy"
          else
            echo "‚ùå System may still have issues after rollback"
            echo "MANUAL INTERVENTION REQUIRED"
          fi

  # Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy, verify, monitor]
    if: always()

    steps:
      - name: Determine final status
        id: status
        run: |
          if [ "${{ needs.monitor.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
            echo "message=Production deployment completed successfully" >> $GITHUB_OUTPUT
          elif [ "${{ job.status }}" == "cancelled" ]; then
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "emoji=‚ö†Ô∏è" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
            echo "message=Production deployment was cancelled" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=‚ùå" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
            echo "message=Production deployment failed - automatic rollback initiated" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack
        uses: slackapi/slack-github-action@v1
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK_PRODUCTION }}
          payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} Production Deployment: ${{ steps.status.outputs.message }}",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "blocks": [
                    {
                      "type": "header",
                      "text": {
                        "type": "plain_text",
                        "text": "${{ steps.status.outputs.emoji }} Apollo Production Deployment"
                      }
                    },
                    {
                      "type": "section",
                      "fields": [
                        {
                          "type": "mrkdwn",
                          "text": "*Status:*\n${{ steps.status.outputs.message }}"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Version:*\n${{ needs.validate.outputs.version }}"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Environment:*\nProduction"
                        },
                        {
                          "type": "mrkdwn",
                          "text": "*Deployed by:*\n${{ github.actor }}"
                        }
                      ]
                    },
                    {
                      "type": "actions",
                      "elements": [
                        {
                          "type": "button",
                          "text": {
                            "type": "plain_text",
                            "text": "View Deployment"
                          },
                          "url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                        },
                        {
                          "type": "button",
                          "text": {
                            "type": "plain_text",
                            "text": "View Production"
                          },
                          "url": "https://apollo-platform.com"
                        }
                      ]
                    }
                  ]
                }
              ]
            }

      - name: Notify Microsoft Teams
        if: always()
        continue-on-error: true
        run: |
          curl -H "Content-Type: application/json" -d '{
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeColor": "${{ steps.status.outputs.status == 'success' && '00FF00' || 'FF0000' }}",
            "summary": "Apollo Production Deployment",
            "sections": [{
              "activityTitle": "${{ steps.status.outputs.emoji }} Apollo Production Deployment",
              "facts": [
                {"name": "Status", "value": "${{ steps.status.outputs.message }}"},
                {"name": "Version", "value": "${{ needs.validate.outputs.version }}"},
                {"name": "Deployed by", "value": "${{ github.actor }}"},
                {"name": "Time", "value": "'"$(date -u)"'"}
              ],
              "markdown": true
            }],
            "potentialAction": [{
              "@type": "OpenUri",
              "name": "View Deployment",
              "targets": [{"os": "default", "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"}]
            }]
          }' "${{ secrets.TEAMS_WEBHOOK_URL }}" || true

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployment } = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ needs.validate.outputs.version }}',
              environment: 'production',
              auto_merge: false,
              required_contexts: [],
              description: 'Production deployment ${{ needs.validate.outputs.version }}'
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.id,
              state: '${{ steps.status.outputs.status }}',
              environment_url: 'https://apollo-platform.com',
              description: '${{ steps.status.outputs.message }}'
            });
