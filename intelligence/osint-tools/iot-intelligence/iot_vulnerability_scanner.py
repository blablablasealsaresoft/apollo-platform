"""
IoT Vulnerability Scanner - Automated IoT Device Security Assessment
Default credential checking, CVE matching, misconfiguration detection, and exploit suggestions
"""

import json
import logging
import hashlib
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from dataclasses import dataclass, asdict
from collections import defaultdict
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class Vulnerability:
    """Vulnerability information"""
    vuln_id: str
    title: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    description: str
    affected_device: str
    affected_version: Optional[str] = None
    cve: Optional[str] = None
    cvss_score: Optional[float] = None
    exploit_available: bool = False
    exploit_db_id: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = None
    discovered_at: str = None

    def __post_init__(self):
        if self.references is None:
            self.references = []
        if self.discovered_at is None:
            self.discovered_at = datetime.utcnow().isoformat()


@dataclass
class ScanResult:
    """Scan result for a device"""
    ip: str
    hostname: Optional[str] = None
    device_type: Optional[str] = None
    vendor: Optional[str] = None
    product: Optional[str] = None
    version: Optional[str] = None
    vulnerabilities: List[Vulnerability] = None
    default_credentials_found: List[Dict] = None
    misconfigurations: List[Dict] = None
    risk_score: float = 0.0
    scan_timestamp: str = None

    def __post_init__(self):
        if self.vulnerabilities is None:
            self.vulnerabilities = []
        if self.default_credentials_found is None:
            self.default_credentials_found = []
        if self.misconfigurations is None:
            self.misconfigurations = []
        if self.scan_timestamp is None:
            self.scan_timestamp = datetime.utcnow().isoformat()


class IoTVulnerabilityScanner:
    """
    IoT Vulnerability Scanner
    Comprehensive security assessment for IoT devices
    """

    def __init__(self):
        """Initialize vulnerability scanner"""
        self.scan_results = []

        # Default credentials database
        self.default_credentials = {
            'hikvision': [
                {'username': 'admin', 'password': '12345'},
                {'username': 'admin', 'password': 'admin'},
                {'username': 'root', 'password': '12345'},
            ],
            'dahua': [
                {'username': 'admin', 'password': 'admin'},
                {'username': 'admin', 'password': '888888'},
                {'username': '666666', 'password': '666666'},
            ],
            'axis': [
                {'username': 'root', 'password': 'pass'},
                {'username': 'admin', 'password': 'admin'},
            ],
            'cisco': [
                {'username': 'admin', 'password': 'admin'},
                {'username': 'cisco', 'password': 'cisco'},
                {'username': 'admin', 'password': 'password'},
            ],
            'mikrotik': [
                {'username': 'admin', 'password': ''},
                {'username': 'admin', 'password': 'admin'},
            ],
            'netgear': [
                {'username': 'admin', 'password': 'password'},
                {'username': 'admin', 'password': '1234'},
            ],
            'synology': [
                {'username': 'admin', 'password': 'admin'},
            ],
            'qnap': [
                {'username': 'admin', 'password': 'admin'},
            ],
            'generic': [
                {'username': 'admin', 'password': 'admin'},
                {'username': 'admin', 'password': 'password'},
                {'username': 'admin', 'password': '1234'},
                {'username': 'admin', 'password': '12345'},
                {'username': 'root', 'password': 'root'},
                {'username': 'root', 'password': 'password'},
                {'username': 'user', 'password': 'user'},
            ],
        }

        # CVE database (sample)
        self.cve_database = {
            'hikvision': [
                {
                    'cve': 'CVE-2017-7921',
                    'title': 'Hikvision IP Camera Authentication Bypass',
                    'severity': 'CRITICAL',
                    'cvss': 9.8,
                    'description': 'Authentication bypass vulnerability allowing unauthorized access',
                    'affected_versions': ['< 5.5.0'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-43221',
                },
                {
                    'cve': 'CVE-2021-36260',
                    'title': 'Hikvision Web Server Command Injection',
                    'severity': 'CRITICAL',
                    'cvss': 9.8,
                    'description': 'Command injection vulnerability in web interface',
                    'affected_versions': ['< 5.7.3'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-50077',
                },
            ],
            'dahua': [
                {
                    'cve': 'CVE-2019-3948',
                    'title': 'Dahua DVR Authentication Bypass',
                    'severity': 'CRITICAL',
                    'cvss': 9.8,
                    'description': 'Authentication bypass in Dahua DVR devices',
                    'affected_versions': ['< 2.800.0000000.0'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-46653',
                },
            ],
            'cisco': [
                {
                    'cve': 'CVE-2019-1653',
                    'title': 'Cisco Small Business Router Remote Code Execution',
                    'severity': 'CRITICAL',
                    'cvss': 9.8,
                    'description': 'Buffer overflow leading to remote code execution',
                    'affected_versions': ['RV320 < 1.4.2.22', 'RV325 < 1.4.2.22'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-46509',
                },
            ],
            'mikrotik': [
                {
                    'cve': 'CVE-2018-14847',
                    'title': 'MikroTik RouterOS Directory Traversal',
                    'severity': 'CRITICAL',
                    'cvss': 9.1,
                    'description': 'Directory traversal vulnerability allowing unauthorized access',
                    'affected_versions': ['< 6.42.7'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-45578',
                },
            ],
            'netgear': [
                {
                    'cve': 'CVE-2020-9377',
                    'title': 'Netgear Router Authentication Bypass',
                    'severity': 'HIGH',
                    'cvss': 8.8,
                    'description': 'Authentication bypass in web interface',
                    'affected_versions': ['Multiple models'],
                    'exploit_available': False,
                },
            ],
            'qnap': [
                {
                    'cve': 'CVE-2021-28799',
                    'title': 'QNAP NAS Command Injection',
                    'severity': 'CRITICAL',
                    'cvss': 9.8,
                    'description': 'Command injection in multimedia console',
                    'affected_versions': ['< 4.5.2'],
                    'exploit_available': True,
                    'exploit_db_id': 'EDB-49589',
                },
            ],
        }

        # Misconfiguration checks
        self.misconfiguration_checks = [
            {
                'id': 'MISC-001',
                'title': 'Telnet Enabled',
                'severity': 'HIGH',
                'description': 'Telnet service is enabled and accessible',
                'port': 23,
            },
            {
                'id': 'MISC-002',
                'title': 'Unencrypted HTTP',
                'severity': 'MEDIUM',
                'description': 'Web interface accessible over unencrypted HTTP',
                'port': 80,
            },
            {
                'id': 'MISC-003',
                'title': 'FTP Enabled',
                'severity': 'MEDIUM',
                'description': 'FTP service is enabled and accessible',
                'port': 21,
            },
            {
                'id': 'MISC-004',
                'title': 'UPnP Exposed',
                'severity': 'MEDIUM',
                'description': 'UPnP service exposed to internet',
                'port': 5000,
            },
            {
                'id': 'MISC-005',
                'title': 'Default Admin Page',
                'severity': 'LOW',
                'description': 'Default admin login page accessible',
                'port': 80,
            },
        ]

    def scan_device(
        self,
        ip: str,
        device_info: Optional[Dict] = None,
        check_credentials: bool = True,
        check_vulnerabilities: bool = True,
        check_misconfigurations: bool = True
    ) -> ScanResult:
        """
        Scan device for vulnerabilities

        Args:
            ip: Device IP address
            device_info: Device information (type, vendor, product, version, ports)
            check_credentials: Check for default credentials
            check_vulnerabilities: Check for known vulnerabilities
            check_misconfigurations: Check for misconfigurations

        Returns:
            Scan result
        """
        logger.info(f"Scanning device: {ip}")

        device_info = device_info or {}

        result = ScanResult(
            ip=ip,
            hostname=device_info.get('hostname'),
            device_type=device_info.get('device_type'),
            vendor=device_info.get('vendor'),
            product=device_info.get('product'),
            version=device_info.get('version'),
        )

        # Check default credentials
        if check_credentials:
            logger.info(f"  Checking default credentials...")
            default_creds = self._check_default_credentials(
                ip,
                device_info.get('vendor'),
                device_info.get('ports', [])
            )
            result.default_credentials_found = default_creds

        # Check vulnerabilities
        if check_vulnerabilities:
            logger.info(f"  Checking known vulnerabilities...")
            vulnerabilities = self._check_vulnerabilities(
                device_info.get('vendor'),
                device_info.get('product'),
                device_info.get('version')
            )
            result.vulnerabilities = vulnerabilities

        # Check misconfigurations
        if check_misconfigurations:
            logger.info(f"  Checking misconfigurations...")
            misconfigs = self._check_misconfigurations(
                ip,
                device_info.get('ports', [])
            )
            result.misconfigurations = misconfigs

        # Calculate risk score
        result.risk_score = self._calculate_risk_score(result)

        self.scan_results.append(result)
        logger.info(f"Scan completed. Risk score: {result.risk_score:.1f}/100")

        return result

    def _check_default_credentials(
        self,
        ip: str,
        vendor: Optional[str],
        ports: List[int]
    ) -> List[Dict]:
        """Check for default credentials"""
        found_credentials = []

        # Get credentials to check
        creds_to_check = []

        if vendor:
            vendor_lower = vendor.lower()
            for key in self.default_credentials:
                if key in vendor_lower:
                    creds_to_check.extend(self.default_credentials[key])

        # Always check generic credentials
        creds_to_check.extend(self.default_credentials['generic'])

        # Simulate credential checking
        # In real implementation, would attempt authentication
        for i, creds in enumerate(creds_to_check[:5]):  # Check first 5
            # Simulate finding default credentials (20% chance)
            if i == 0 and vendor:  # First credential for vendor more likely
                found_credentials.append({
                    'username': creds['username'],
                    'password': creds['password'],
                    'service': 'http' if 80 in ports else 'telnet' if 23 in ports else 'ssh',
                    'severity': 'CRITICAL',
                })
                break

        return found_credentials

    def _check_vulnerabilities(
        self,
        vendor: Optional[str],
        product: Optional[str],
        version: Optional[str]
    ) -> List[Vulnerability]:
        """Check for known vulnerabilities"""
        vulnerabilities = []

        if not vendor:
            return vulnerabilities

        vendor_lower = vendor.lower()

        # Find matching CVEs
        for key, cves in self.cve_database.items():
            if key in vendor_lower:
                for cve_data in cves:
                    # Check version if available
                    affected = True
                    if version and cve_data.get('affected_versions'):
                        affected = self._is_version_affected(version, cve_data['affected_versions'])

                    if affected:
                        vuln = Vulnerability(
                            vuln_id=cve_data['cve'],
                            title=cve_data['title'],
                            severity=cve_data['severity'],
                            description=cve_data['description'],
                            affected_device=f"{vendor} {product or 'Device'}",
                            affected_version=version,
                            cve=cve_data['cve'],
                            cvss_score=cve_data.get('cvss'),
                            exploit_available=cve_data.get('exploit_available', False),
                            exploit_db_id=cve_data.get('exploit_db_id'),
                            remediation=f"Update to latest firmware version",
                            references=[
                                f"https://nvd.nist.gov/vuln/detail/{cve_data['cve']}",
                            ],
                        )
                        vulnerabilities.append(vuln)

        return vulnerabilities

    def _is_version_affected(self, version: str, affected_versions: List[str]) -> bool:
        """Check if version is affected by vulnerability"""
        # Simplified version checking
        # In real implementation, would do proper version comparison
        for affected in affected_versions:
            if '<' in affected:
                # e.g., "< 5.5.0"
                return True  # Simplified - assume affected
            elif version in affected:
                return True

        return False

    def _check_misconfigurations(self, ip: str, ports: List[int]) -> List[Dict]:
        """Check for misconfigurations"""
        misconfigs = []

        for check in self.misconfiguration_checks:
            if check['port'] in ports:
                misconfig = {
                    'id': check['id'],
                    'title': check['title'],
                    'severity': check['severity'],
                    'description': check['description'],
                    'port': check['port'],
                    'remediation': self._get_misconfiguration_remediation(check['id']),
                }
                misconfigs.append(misconfig)

        return misconfigs

    def _get_misconfiguration_remediation(self, misc_id: str) -> str:
        """Get remediation advice for misconfiguration"""
        remediation_map = {
            'MISC-001': 'Disable Telnet and use SSH instead',
            'MISC-002': 'Enable HTTPS and redirect HTTP to HTTPS',
            'MISC-003': 'Disable FTP or use SFTP/FTPS instead',
            'MISC-004': 'Disable UPnP or restrict to local network only',
            'MISC-005': 'Change default login page URL or implement rate limiting',
        }
        return remediation_map.get(misc_id, 'Review and harden configuration')

    def _calculate_risk_score(self, result: ScanResult) -> float:
        """Calculate overall risk score"""
        score = 0.0

        # Default credentials (max 40 points)
        if result.default_credentials_found:
            score += 40.0

        # Vulnerabilities (max 40 points)
        if result.vulnerabilities:
            critical = len([v for v in result.vulnerabilities if v.severity == 'CRITICAL'])
            high = len([v for v in result.vulnerabilities if v.severity == 'HIGH'])
            medium = len([v for v in result.vulnerabilities if v.severity == 'MEDIUM'])

            score += min(critical * 15, 30)
            score += min(high * 7, 15)
            score += min(medium * 3, 10)

        # Misconfigurations (max 20 points)
        if result.misconfigurations:
            for misc in result.misconfigurations:
                if misc['severity'] == 'HIGH':
                    score += 8
                elif misc['severity'] == 'MEDIUM':
                    score += 4
                elif misc['severity'] == 'LOW':
                    score += 2

        return min(score, 100.0)

    def generate_exploit_suggestions(self, result: ScanResult) -> List[Dict]:
        """
        Generate exploit suggestions for vulnerabilities

        Args:
            result: Scan result

        Returns:
            List of exploit suggestions
        """
        suggestions = []

        # Default credentials exploitation
        for creds in result.default_credentials_found:
            suggestion = {
                'type': 'default_credentials',
                'severity': 'CRITICAL',
                'title': 'Default Credential Access',
                'description': f"Device accessible with default credentials: {creds['username']}:{creds['password']}",
                'exploit_method': f"Login to {creds['service']} service using default credentials",
                'tools': ['hydra', 'medusa', 'custom script'],
                'impact': 'Full device compromise',
            }
            suggestions.append(suggestion)

        # CVE exploits
        for vuln in result.vulnerabilities:
            if vuln.exploit_available:
                suggestion = {
                    'type': 'cve_exploit',
                    'severity': vuln.severity,
                    'title': f"Exploit {vuln.cve}",
                    'description': vuln.description,
                    'exploit_method': f"Use existing exploit from Exploit-DB: {vuln.exploit_db_id}",
                    'tools': ['metasploit', 'exploit-db', 'custom exploit'],
                    'impact': 'Remote code execution or unauthorized access',
                    'cve': vuln.cve,
                    'exploit_db_id': vuln.exploit_db_id,
                }
                suggestions.append(suggestion)

        # Misconfiguration exploits
        for misc in result.misconfigurations:
            if misc['id'] == 'MISC-001':  # Telnet
                suggestion = {
                    'type': 'misconfiguration',
                    'severity': misc['severity'],
                    'title': 'Telnet Brute Force',
                    'description': 'Telnet service can be brute-forced',
                    'exploit_method': 'Brute force telnet credentials',
                    'tools': ['hydra', 'medusa', 'ncrack'],
                    'impact': 'Credential compromise',
                }
                suggestions.append(suggestion)

        return suggestions

    def generate_report(
        self,
        output_file: str = "vulnerability_scan_report.json",
        include_exploits: bool = True
    ) -> Dict:
        """Generate comprehensive vulnerability report"""

        report = {
            'generated_at': datetime.utcnow().isoformat(),
            'summary': {
                'total_devices_scanned': len(self.scan_results),
                'vulnerable_devices': len([r for r in self.scan_results if r.vulnerabilities]),
                'devices_with_default_creds': len([r for r in self.scan_results if r.default_credentials_found]),
                'critical_vulnerabilities': sum(len([v for v in r.vulnerabilities if v.severity == 'CRITICAL']) for r in self.scan_results),
                'high_vulnerabilities': sum(len([v for v in r.vulnerabilities if v.severity == 'HIGH']) for r in self.scan_results),
                'average_risk_score': sum(r.risk_score for r in self.scan_results) / len(self.scan_results) if self.scan_results else 0,
            },
            'scan_results': [],
        }

        # Add detailed results
        for result in self.scan_results:
            result_dict = asdict(result)

            if include_exploits and (result.vulnerabilities or result.default_credentials_found):
                result_dict['exploit_suggestions'] = self.generate_exploit_suggestions(result)

            report['scan_results'].append(result_dict)

        # Top vulnerabilities
        vuln_counts = defaultdict(int)
        for result in self.scan_results:
            for vuln in result.vulnerabilities:
                vuln_counts[vuln.cve] += 1

        report['top_vulnerabilities'] = [
            {'cve': cve, 'count': count}
            for cve, count in sorted(vuln_counts.items(), key=lambda x: x[1], reverse=True)[:10]
        ]

        # Save to file
        try:
            with open(output_file, 'w') as f:
                json.dump(report, f, indent=2)
            logger.info(f"Report saved to {output_file}")
        except Exception as e:
            logger.error(f"Error saving report: {e}")

        return report

    def get_high_risk_devices(self, min_risk_score: float = 70.0) -> List[ScanResult]:
        """Get devices with high risk scores"""
        return [r for r in self.scan_results if r.risk_score >= min_risk_score]


def main():
    """Example usage"""
    print("IoT Vulnerability Scanner")
    print("=" * 50)

    # Initialize scanner
    scanner = IoTVulnerabilityScanner()

    # Example device info
    devices = [
        {
            'ip': '192.168.1.100',
            'hostname': 'camera1.local',
            'device_type': 'webcam',
            'vendor': 'Hikvision',
            'product': 'DS-2CD2142FWD-I',
            'version': '5.4.0',
            'ports': [80, 554, 8000],
        },
        {
            'ip': '192.168.1.101',
            'hostname': 'router1.local',
            'device_type': 'router',
            'vendor': 'Cisco',
            'product': 'RV320',
            'version': '1.4.2.15',
            'ports': [80, 443, 23],
        },
        {
            'ip': '192.168.1.102',
            'hostname': 'nas1.local',
            'device_type': 'nas',
            'vendor': 'QNAP',
            'product': 'TS-251',
            'version': '4.5.1',
            'ports': [80, 443, 21],
        },
    ]

    # Scan devices
    print("\n[*] Scanning devices...")
    for device_info in devices:
        print(f"\n  Scanning {device_info['ip']} ({device_info['vendor']})...")
        result = scanner.scan_device(device_info['ip'], device_info)

        print(f"    Risk Score: {result.risk_score:.1f}/100")
        print(f"    Vulnerabilities: {len(result.vulnerabilities)}")
        print(f"    Default Credentials: {len(result.default_credentials_found)}")
        print(f"    Misconfigurations: {len(result.misconfigurations)}")

        # Show vulnerabilities
        if result.vulnerabilities:
            print(f"\n    Found Vulnerabilities:")
            for vuln in result.vulnerabilities[:3]:
                print(f"      - {vuln.cve}: {vuln.title} ({vuln.severity})")
                if vuln.exploit_available:
                    print(f"        Exploit Available: {vuln.exploit_db_id}")

        # Show default credentials
        if result.default_credentials_found:
            print(f"\n    Default Credentials Found:")
            for creds in result.default_credentials_found:
                print(f"      - {creds['username']}:{creds['password']} ({creds['service']})")

        # Show exploit suggestions
        exploits = scanner.generate_exploit_suggestions(result)
        if exploits:
            print(f"\n    Exploit Suggestions:")
            for exploit in exploits[:2]:
                print(f"      - {exploit['title']}")
                print(f"        Method: {exploit['exploit_method']}")

    # Get high-risk devices
    print("\n[*] High-risk devices:")
    high_risk = scanner.get_high_risk_devices(min_risk_score=50.0)
    print(f"  Found {len(high_risk)} high-risk devices")

    for device in high_risk:
        print(f"\n    {device.ip} - {device.vendor} ({device.risk_score:.1f}/100)")

    # Generate report
    print("\n[*] Generating vulnerability report...")
    report = scanner.generate_report()
    print(f"[+] Report generated")
    print(f"  Total devices: {report['summary']['total_devices_scanned']}")
    print(f"  Vulnerable: {report['summary']['vulnerable_devices']}")
    print(f"  Critical vulnerabilities: {report['summary']['critical_vulnerabilities']}")
    print(f"  Average risk score: {report['summary']['average_risk_score']:.1f}/100")


if __name__ == "__main__":
    main()
