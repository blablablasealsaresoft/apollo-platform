/**
 * Apollo HTML Exporter
 *
 * Professional HTML report generation with:
 * - Responsive design
 * - Classification markings
 * - Print-ready styling
 * - Interactive charts (Chart.js)
 * - Collapsible sections
 * - Dark/Light mode support
 */

import {
  ReportGenerationOptions,
  ClassificationMarking,
  ReportSection,
  ReportTable,
  ReportChart,
  ReportImage,
} from '../types';

// Classification colors
const CLASSIFICATION_COLORS: Record<ClassificationMarking, { bg: string; text: string }> = {
  [ClassificationMarking.TOP_SECRET_SCI]: { bg: '#FFD700', text: '#000000' },
  [ClassificationMarking.TOP_SECRET]: { bg: '#FFA500', text: '#000000' },
  [ClassificationMarking.SECRET]: { bg: '#FF0000', text: '#FFFFFF' },
  [ClassificationMarking.CONFIDENTIAL]: { bg: '#0000FF', text: '#FFFFFF' },
  [ClassificationMarking.RESTRICTED]: { bg: '#00FF00', text: '#000000' },
  [ClassificationMarking.UNCLASSIFIED]: { bg: '#008000', text: '#FFFFFF' },
  [ClassificationMarking.UNCLASSIFIED_FOUO]: { bg: '#808080', text: '#FFFFFF' },
};

interface FormattedReportData {
  title: string;
  subtitle?: string;
  classification: ClassificationMarking;
  generatedDate: Date;
  author?: string;
  sections: ReportSection[];
  tables?: ReportTable[];
  charts?: ReportChart[];
  images?: ReportImage[];
  footer?: string;
  metadata?: Record<string, any>;
}

export class HTMLExporter {
  /**
   * Export formatted data to HTML buffer
   */
  async export(
    data: FormattedReportData,
    options: ReportGenerationOptions
  ): Promise<{ buffer: Buffer; mimeType: string }> {
    const html = this.generateHTML(data, options);
    return {
      buffer: Buffer.from(html, 'utf-8'),
      mimeType: 'text/html',
    };
  }

  /**
   * Generate complete HTML document
   */
  private generateHTML(data: FormattedReportData, options: ReportGenerationOptions): string {
    const classification = data.classification;
    const colors = CLASSIFICATION_COLORS[classification];

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="classification" content="${classification}">
  <meta name="author" content="${data.author || 'Apollo Intelligence Platform'}">
  <meta name="generator" content="Apollo Report Generator">
  <title>${this.escapeHtml(data.title)} - ${classification}</title>
  ${this.generateStyles(data, options)}
  ${this.generateChartScript()}
</head>
<body>
  <!-- Classification Header -->
  <header class="classification-banner">
    ${classification}
  </header>

  <!-- Report Container -->
  <div class="report-container">
    <!-- Cover Section -->
    ${this.generateCoverSection(data, options)}

    <!-- Table of Contents -->
    ${options.includeTableOfContents ? this.generateTableOfContents(data) : ''}

    <!-- Content Sections -->
    <main class="report-content">
      ${data.sections.map((section, index) => this.generateSection(section, index, 0)).join('\n')}
    </main>

    <!-- Charts Section -->
    ${data.charts && data.charts.length > 0 ? this.generateChartsSection(data.charts, options) : ''}

    <!-- Tables Section -->
    ${data.tables && data.tables.length > 0 ? this.generateTablesSection(data.tables, options) : ''}

    <!-- Footer -->
    <footer class="report-footer">
      <div class="footer-content">
        ${data.footer ? `<p>${this.escapeHtml(data.footer)}</p>` : ''}
        <p class="generation-info">Generated by Apollo Intelligence Platform on ${this.formatDate(data.generatedDate)}</p>
      </div>
    </footer>
  </div>

  <!-- Classification Footer -->
  <footer class="classification-banner classification-footer">
    ${classification}
  </footer>

  ${this.generatePrintStyles(data, options)}
  ${this.generateInteractiveScript()}
</body>
</html>`;
  }

  /**
   * Generate CSS styles
   */
  private generateStyles(data: FormattedReportData, options: ReportGenerationOptions): string {
    const classification = data.classification;
    const colors = CLASSIFICATION_COLORS[classification];
    const fontSize = options.fontSize || 11;

    return `<style>
/* CSS Reset and Base */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

:root {
  --primary-color: #1a1a2e;
  --secondary-color: #4a4a68;
  --accent-color: #0066cc;
  --text-color: #333333;
  --text-light: #666666;
  --background: #ffffff;
  --background-alt: #f5f5f5;
  --border-color: #cccccc;
  --classification-bg: ${colors.bg};
  --classification-text: ${colors.text};
  --font-size-base: ${fontSize}pt;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  :root {
    --text-color: #e0e0e0;
    --text-light: #a0a0a0;
    --background: #1a1a2e;
    --background-alt: #2a2a4e;
    --border-color: #444444;
  }
}

body {
  font-family: ${options.fontFamily || 'Helvetica, Arial, sans-serif'};
  font-size: var(--font-size-base);
  line-height: 1.6;
  color: var(--text-color);
  background: var(--background);
}

/* Classification Banners */
.classification-banner {
  background: var(--classification-bg);
  color: var(--classification-text);
  text-align: center;
  padding: 8px 16px;
  font-weight: bold;
  font-size: 14px;
  position: fixed;
  width: 100%;
  z-index: 1000;
}

.classification-banner:first-child {
  top: 0;
}

.classification-footer {
  position: fixed;
  bottom: 0;
}

/* Report Container */
.report-container {
  max-width: 900px;
  margin: 60px auto;
  padding: 40px;
  background: var(--background);
}

/* Cover Section */
.cover-section {
  text-align: center;
  padding: 60px 20px;
  border-bottom: 2px solid var(--primary-color);
  margin-bottom: 40px;
}

.logo-placeholder {
  width: 100px;
  height: 100px;
  margin: 0 auto 30px;
  border: 2px solid var(--primary-color);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  color: var(--primary-color);
}

.report-title {
  font-size: 2.5em;
  color: var(--primary-color);
  margin-bottom: 10px;
  font-weight: bold;
}

.report-subtitle {
  font-size: 1.3em;
  color: var(--secondary-color);
  margin-bottom: 30px;
}

.report-metadata {
  font-size: 0.9em;
  color: var(--text-light);
}

.report-metadata p {
  margin: 5px 0;
}

.handling-instructions {
  margin-top: 30px;
  padding: 15px;
  border: 1px solid var(--border-color);
  text-align: left;
  font-size: 0.85em;
}

.handling-instructions h4 {
  margin-bottom: 10px;
  text-decoration: underline;
}

/* Table of Contents */
.toc-section {
  margin-bottom: 40px;
  padding: 20px;
  background: var(--background-alt);
  border-radius: 8px;
}

.toc-section h2 {
  margin-bottom: 20px;
  color: var(--primary-color);
}

.toc-list {
  list-style: none;
}

.toc-list li {
  padding: 5px 0;
  border-bottom: 1px dotted var(--border-color);
}

.toc-list li a {
  color: var(--accent-color);
  text-decoration: none;
}

.toc-list li a:hover {
  text-decoration: underline;
}

.toc-list .toc-level-1 { margin-left: 0; font-weight: bold; }
.toc-list .toc-level-2 { margin-left: 20px; }
.toc-list .toc-level-3 { margin-left: 40px; font-size: 0.9em; }

/* Content Sections */
.report-content {
  margin-bottom: 40px;
}

.section {
  margin-bottom: 30px;
}

.section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
}

.section-header:hover {
  background: var(--background-alt);
}

.section h1 {
  font-size: 1.8em;
  color: var(--primary-color);
  border-bottom: 2px solid var(--primary-color);
  padding-bottom: 10px;
  margin-bottom: 15px;
}

.section h2 {
  font-size: 1.4em;
  color: var(--primary-color);
  margin-bottom: 12px;
}

.section h3 {
  font-size: 1.2em;
  color: var(--secondary-color);
  margin-bottom: 10px;
}

.section h4 {
  font-size: 1.1em;
  color: var(--secondary-color);
  margin-bottom: 8px;
}

.section-content {
  padding-left: 0;
}

.section-content p {
  margin-bottom: 15px;
  text-align: justify;
}

.subsection {
  margin-left: 20px;
  padding-left: 20px;
  border-left: 2px solid var(--background-alt);
}

/* Tables */
.data-table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 0.9em;
}

.data-table caption {
  font-weight: bold;
  font-size: 1.1em;
  margin-bottom: 10px;
  text-align: left;
  color: var(--primary-color);
}

.data-table th {
  background: var(--primary-color);
  color: white;
  padding: 12px;
  text-align: left;
  font-weight: bold;
}

.data-table td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border-color);
}

.data-table tr:nth-child(even) {
  background: var(--background-alt);
}

.data-table tr:hover {
  background: #e8e8e8;
}

.data-table tfoot td {
  background: var(--background-alt);
  font-weight: bold;
}

/* Charts Section */
.charts-section {
  margin: 40px 0;
}

.charts-section h2 {
  color: var(--primary-color);
  margin-bottom: 20px;
}

.chart-container {
  margin: 20px 0;
  padding: 20px;
  background: var(--background-alt);
  border-radius: 8px;
}

.chart-title {
  font-weight: bold;
  margin-bottom: 15px;
  color: var(--primary-color);
}

.chart-canvas {
  max-width: 100%;
  height: 300px;
}

/* Footer */
.report-footer {
  margin-top: 40px;
  padding-top: 20px;
  border-top: 2px solid var(--primary-color);
  text-align: center;
  color: var(--text-light);
  font-size: 0.85em;
}

.generation-info {
  margin-top: 10px;
  font-style: italic;
}

/* Utility Classes */
.page-break {
  page-break-after: always;
}

.no-print {
  display: block;
}

/* Responsive */
@media (max-width: 768px) {
  .report-container {
    margin: 50px 10px;
    padding: 20px;
  }

  .report-title {
    font-size: 1.8em;
  }

  .classification-banner {
    font-size: 12px;
    padding: 6px 10px;
  }
}
</style>`;
  }

  /**
   * Generate Chart.js script inclusion
   */
  private generateChartScript(): string {
    return `<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>`;
  }

  /**
   * Generate cover section HTML
   */
  private generateCoverSection(data: FormattedReportData, options: ReportGenerationOptions): string {
    const classification = data.classification;

    return `
    <section class="cover-section">
      <div class="logo-placeholder">APOLLO</div>
      <h1 class="report-title">${this.escapeHtml(data.title)}</h1>
      ${data.subtitle ? `<p class="report-subtitle">${this.escapeHtml(data.subtitle)}</p>` : ''}

      <div class="report-metadata">
        <p><strong>Generated:</strong> ${this.formatDate(data.generatedDate)}</p>
        ${data.author ? `<p><strong>Prepared by:</strong> ${this.escapeHtml(data.author)}</p>` : ''}
        <p><strong>Classification:</strong> ${classification}</p>
        ${data.metadata?.reportId ? `<p><strong>Report ID:</strong> ${data.metadata.reportId}</p>` : ''}
      </div>

      ${classification !== ClassificationMarking.UNCLASSIFIED ? `
      <div class="handling-instructions">
        <h4>HANDLING INSTRUCTIONS</h4>
        <p>${this.getHandlingInstructions(classification)}</p>
      </div>
      ` : ''}
    </section>`;
  }

  /**
   * Generate table of contents HTML
   */
  private generateTableOfContents(data: FormattedReportData): string {
    const tocItems = this.extractTocItems(data.sections);

    return `
    <nav class="toc-section">
      <h2>Table of Contents</h2>
      <ol class="toc-list">
        ${tocItems.map((item) => `
          <li class="toc-level-${item.level}">
            <a href="#section-${item.id}">${this.escapeHtml(item.title)}</a>
          </li>
        `).join('')}
      </ol>
    </nav>`;
  }

  /**
   * Extract TOC items from sections
   */
  private extractTocItems(sections: ReportSection[], level: number = 1): { id: string; title: string; level: number }[] {
    const items: { id: string; title: string; level: number }[] = [];

    sections.forEach((section) => {
      items.push({ id: section.id, title: section.title, level });
      if (section.subsections) {
        items.push(...this.extractTocItems(section.subsections, level + 1));
      }
    });

    return items;
  }

  /**
   * Generate section HTML
   */
  private generateSection(section: ReportSection, index: number, level: number): string {
    const headingLevel = Math.min(level + 1, 4);
    const headingTag = `h${headingLevel}`;

    return `
    <section class="section ${level > 0 ? 'subsection' : ''}" id="section-${section.id}">
      <${headingTag}>${this.escapeHtml(section.title)}</${headingTag}>
      <div class="section-content">
        ${this.formatContent(section.content)}
        ${section.subsections ? section.subsections.map((sub, subIndex) =>
          this.generateSection(sub, subIndex, level + 1)
        ).join('') : ''}
      </div>
      ${section.pageBreakAfter ? '<div class="page-break"></div>' : ''}
    </section>`;
  }

  /**
   * Format content text to HTML
   */
  private formatContent(content: string): string {
    if (!content) return '';

    // Split into paragraphs and format
    const paragraphs = content.split('\n\n');
    return paragraphs
      .filter((p) => p.trim())
      .map((p) => `<p>${this.escapeHtml(p.trim())}</p>`)
      .join('\n');
  }

  /**
   * Generate charts section HTML
   */
  private generateChartsSection(charts: ReportChart[], options: ReportGenerationOptions): string {
    return `
    <section class="charts-section">
      <h2>Charts and Visualizations</h2>
      ${charts.map((chart, index) => this.generateChart(chart, index)).join('\n')}
    </section>`;
  }

  /**
   * Generate individual chart HTML
   */
  private generateChart(chart: ReportChart, index: number): string {
    const canvasId = `chart-${index}`;
    const chartData = chart.data as { labels: string[]; values: number[] };

    return `
    <div class="chart-container">
      <div class="chart-title">${this.escapeHtml(chart.title)}</div>
      <canvas id="${canvasId}" class="chart-canvas"></canvas>
      <script>
        (function() {
          const ctx = document.getElementById('${canvasId}').getContext('2d');
          new Chart(ctx, {
            type: '${chart.type === 'pie' ? 'doughnut' : chart.type}',
            data: {
              labels: ${JSON.stringify(chartData.labels || [])},
              datasets: [{
                data: ${JSON.stringify(chartData.values || [])},
                backgroundColor: ['#1a1a2e', '#4a4a68', '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4'],
                borderColor: '#ffffff',
                borderWidth: 1
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  position: '${chart.type === 'pie' ? 'right' : 'top'}'
                }
              }
            }
          });
        })();
      </script>
    </div>`;
  }

  /**
   * Generate tables section HTML
   */
  private generateTablesSection(tables: ReportTable[], options: ReportGenerationOptions): string {
    return tables.map((table) => this.generateTable(table)).join('\n');
  }

  /**
   * Generate table HTML
   */
  private generateTable(table: ReportTable): string {
    return `
    <table class="data-table">
      ${table.title ? `<caption>${this.escapeHtml(table.title)}</caption>` : ''}
      <thead>
        <tr>
          ${table.headers.map((header) => `<th>${this.escapeHtml(header)}</th>`).join('')}
        </tr>
      </thead>
      <tbody>
        ${table.rows.map((row) => `
          <tr>
            ${row.map((cell) => `<td>${this.escapeHtml(String(cell ?? ''))}</td>`).join('')}
          </tr>
        `).join('')}
      </tbody>
      ${table.footers ? `
        <tfoot>
          <tr>
            ${table.footers.map((footer) => `<td>${this.escapeHtml(footer)}</td>`).join('')}
          </tr>
        </tfoot>
      ` : ''}
    </table>`;
  }

  /**
   * Generate print-specific styles
   */
  private generatePrintStyles(data: FormattedReportData, options: ReportGenerationOptions): string {
    const colors = CLASSIFICATION_COLORS[data.classification];

    return `<style>
@media print {
  .classification-banner {
    position: static;
    margin-bottom: 20px;
  }

  .classification-footer {
    position: static;
    margin-top: 20px;
  }

  .report-container {
    margin: 0;
    padding: 20px;
    max-width: none;
  }

  .no-print {
    display: none !important;
  }

  .page-break {
    page-break-after: always;
  }

  @page {
    size: ${options.pageSize || 'letter'} ${options.orientation || 'portrait'};
    margin: 1in;

    @top-center {
      content: "${data.classification}";
      font-weight: bold;
      background: ${colors.bg};
      color: ${colors.text};
      padding: 5px 20px;
    }

    @bottom-center {
      content: "${data.classification}";
      font-weight: bold;
      background: ${colors.bg};
      color: ${colors.text};
      padding: 5px 20px;
    }

    @bottom-right {
      content: "Page " counter(page) " of " counter(pages);
    }
  }
}
</style>`;
  }

  /**
   * Generate interactive JavaScript
   */
  private generateInteractiveScript(): string {
    return `<script>
// Collapsible sections
document.querySelectorAll('.section-header').forEach(header => {
  header.addEventListener('click', () => {
    const content = header.nextElementSibling;
    content.style.display = content.style.display === 'none' ? 'block' : 'none';
  });
});

// Print functionality
function printReport() {
  window.print();
}

// Export as HTML file
function exportHTML() {
  const html = document.documentElement.outerHTML;
  const blob = new Blob([html], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = document.title + '.html';
  a.click();
  URL.revokeObjectURL(url);
}
</script>`;
  }

  /**
   * Get handling instructions based on classification
   */
  private getHandlingInstructions(classification: ClassificationMarking): string {
    const instructions: Record<ClassificationMarking, string> = {
      [ClassificationMarking.TOP_SECRET_SCI]:
        'This document contains TOP SECRET//SCI information. Handle via SCI channels only. ' +
        'Do not disseminate without proper authorization. Destroy by approved methods only.',
      [ClassificationMarking.TOP_SECRET]:
        'This document contains TOP SECRET information. Handle via secure channels only. ' +
        'Unauthorized disclosure may cause exceptionally grave damage to national security.',
      [ClassificationMarking.SECRET]:
        'This document contains SECRET information. Handle via secure channels. ' +
        'Unauthorized disclosure may cause serious damage to national security.',
      [ClassificationMarking.CONFIDENTIAL]:
        'This document contains CONFIDENTIAL information. Protect from unauthorized disclosure.',
      [ClassificationMarking.RESTRICTED]:
        'This document contains RESTRICTED information. Limited distribution authorized.',
      [ClassificationMarking.UNCLASSIFIED]:
        'This document is UNCLASSIFIED. No special handling required.',
      [ClassificationMarking.UNCLASSIFIED_FOUO]:
        'This document is UNCLASSIFIED//FOR OFFICIAL USE ONLY. ' +
        'Exempt from public release under applicable exemptions.',
    };
    return instructions[classification];
  }

  /**
   * Escape HTML special characters
   */
  private escapeHtml(text: string): string {
    const escapeMap: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;',
    };
    return text.replace(/[&<>"']/g, (char) => escapeMap[char]);
  }

  /**
   * Format date for display
   */
  private formatDate(date: Date): string {
    return new Date(date).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  }
}

export const htmlExporter = new HTMLExporter();
