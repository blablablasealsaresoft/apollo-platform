# Apollo Platform Logstash Pipeline
# Comprehensive log processing for all services

input {
  # Filebeat input for service logs
  beats {
    port => 5044
    ssl => false
    tags => ["beats"]
  }

  # Direct TCP input for services
  tcp {
    port => 5000
    codec => json_lines
    tags => ["tcp"]
  }

  # Kafka input for high-throughput log streams
  kafka {
    bootstrap_servers => "${KAFKA_HOSTS:kafka:9092}"
    topics => ["apollo-logs", "apollo-audit", "apollo-security"]
    group_id => "logstash-apollo"
    codec => json
    tags => ["kafka"]
  }

  # Syslog input for infrastructure components
  syslog {
    port => 5514
    tags => ["syslog"]
  }
}

filter {
  # Parse JSON messages
  if [message] =~ /^\{/ {
    json {
      source => "message"
      skip_on_invalid_json => true
      target => "parsed"
    }

    # Promote parsed fields to top level
    if [parsed] {
      mutate {
        rename => {
          "[parsed][level]" => "level"
          "[parsed][service]" => "service"
          "[parsed][timestamp]" => "log_timestamp"
          "[parsed][message]" => "log_message"
          "[parsed][trace_id]" => "trace_id"
          "[parsed][span_id]" => "span_id"
          "[parsed][user_id]" => "user_id"
          "[parsed][request_id]" => "request_id"
        }
        remove_field => ["parsed"]
      }
    }
  }

  # Normalize log levels
  if [level] {
    mutate {
      lowercase => ["level"]
    }
    translate {
      field => "level"
      destination => "severity"
      dictionary => {
        "trace" => "7"
        "debug" => "7"
        "info" => "6"
        "notice" => "5"
        "warn" => "4"
        "warning" => "4"
        "error" => "3"
        "err" => "3"
        "critical" => "2"
        "crit" => "2"
        "alert" => "1"
        "fatal" => "0"
        "emergency" => "0"
      }
      fallback => "6"
    }
  }

  # Service-specific parsing
  if [service] == "authentication" {
    grok {
      match => {
        "log_message" => [
          "%{WORD:auth_action} %{WORD:auth_result} for user %{USERNAME:username} from %{IP:source_ip}",
          "Token %{WORD:token_action} for user %{USERNAME:username}",
          "MFA %{WORD:mfa_action} for user %{USERNAME:username}"
        ]
      }
      tag_on_failure => ["_auth_grok_failure"]
    }

    # Flag security-relevant auth events
    if [auth_result] == "failed" or [auth_result] == "failure" {
      mutate {
        add_tag => ["security_event", "auth_failure"]
      }
    }
  }

  # API Gateway logs
  if [service] == "api-gateway" {
    grok {
      match => {
        "log_message" => [
          "%{IP:client_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] \"%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}\" %{NUMBER:status} %{NUMBER:bytes} \"%{DATA:referrer}\" \"%{DATA:user_agent}\" %{NUMBER:response_time}",
          "Rate limit exceeded for %{IP:client_ip} on %{DATA:endpoint}"
        ]
      }
      tag_on_failure => ["_gateway_grok_failure"]
    }

    # Flag rate limit events
    if "Rate limit exceeded" in [log_message] {
      mutate {
        add_tag => ["rate_limit", "security_event"]
      }
    }
  }

  # Investigation service logs
  if [service] == "investigation" {
    grok {
      match => {
        "log_message" => [
          "Investigation %{UUID:investigation_id} %{WORD:investigation_action}",
          "Target %{UUID:target_id} %{WORD:target_action} in investigation %{UUID:investigation_id}"
        ]
      }
      tag_on_failure => ["_investigation_grok_failure"]
    }

    # Add investigation metadata
    mutate {
      add_field => { "[@metadata][index_prefix]" => "apollo-investigations" }
    }
  }

  # Facial recognition service logs
  if [service] == "facial-recognition" or [service] == "surveillance" {
    grok {
      match => {
        "log_message" => [
          "Match detected: target %{UUID:target_id} confidence %{NUMBER:confidence} at %{DATA:location}",
          "Processing %{NUMBER:frame_count} frames from %{DATA:camera_id}",
          "Scan completed: %{NUMBER:faces_detected} faces detected"
        ]
      }
      tag_on_failure => ["_fr_grok_failure"]
    }

    # Flag target matches
    if "Match detected" in [log_message] {
      mutate {
        add_tag => ["target_match", "high_priority"]
      }
    }

    mutate {
      add_field => { "[@metadata][index_prefix]" => "apollo-surveillance" }
    }
  }

  # Blockchain tracking logs
  if [service] == "blockchain" or [service] == "blockchain-tracker" {
    grok {
      match => {
        "log_message" => [
          "Transaction %{DATA:tx_hash} traced on %{WORD:chain}",
          "Wallet %{DATA:wallet_address} flagged: %{DATA:flag_reason}",
          "New activity on monitored wallet %{DATA:wallet_address}"
        ]
      }
      tag_on_failure => ["_blockchain_grok_failure"]
    }

    # Flag suspicious blockchain activity
    if [flag_reason] {
      mutate {
        add_tag => ["blockchain_alert", "investigation_lead"]
      }
    }

    mutate {
      add_field => { "[@metadata][index_prefix]" => "apollo-blockchain" }
    }
  }

  # OSINT collection logs
  if [service] == "osint" or [service] == "intelligence" {
    grok {
      match => {
        "log_message" => [
          "Collected %{NUMBER:record_count} records from %{DATA:source}",
          "Correlation found: %{DATA:correlation_type} between %{DATA:entity1} and %{DATA:entity2}"
        ]
      }
      tag_on_failure => ["_osint_grok_failure"]
    }

    mutate {
      add_field => { "[@metadata][index_prefix]" => "apollo-osint" }
    }
  }

  # Security audit logs
  if "audit" in [tags] or [log_type] == "audit" {
    mutate {
      add_tag => ["audit_log"]
      add_field => { "[@metadata][index_prefix]" => "apollo-audit" }
    }

    # Parse audit-specific fields
    grok {
      match => {
        "log_message" => [
          "User %{USERNAME:actor} performed %{WORD:action} on %{DATA:resource}",
          "Admin action: %{DATA:admin_action} by %{USERNAME:admin_user}"
        ]
      }
      tag_on_failure => ["_audit_grok_failure"]
    }
  }

  # GeoIP enrichment for IP addresses
  if [source_ip] {
    geoip {
      source => "source_ip"
      target => "geoip"
      database => "/usr/share/GeoIP/GeoLite2-City.mmdb"
      add_field => { "[geoip][coordinates]" => "%{[geoip][longitude]},%{[geoip][latitude]}" }
    }
  }

  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "client_geoip"
      database => "/usr/share/GeoIP/GeoLite2-City.mmdb"
    }
  }

  # User agent parsing
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }

  # Add processing metadata
  mutate {
    add_field => {
      "[@metadata][index]" => "%{[@metadata][index_prefix]:apollo}-%{+YYYY.MM.dd}"
      "processed_at" => "%{@timestamp}"
      "pipeline_version" => "2.0"
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["beat", "host", "prospector", "input", "offset"]
  }
}

output {
  # Main Elasticsearch output
  elasticsearch {
    hosts => ["${ES_HOSTS:elasticsearch:9200}"]
    index => "%{[@metadata][index]}"
    template_name => "apollo-logs"
    template_overwrite => true
    ilm_enabled => true
    ilm_rollover_alias => "apollo-logs"
    ilm_pattern => "{now/d}-000001"
    ilm_policy => "apollo-log-policy"
  }

  # Security events to dedicated index
  if "security_event" in [tags] {
    elasticsearch {
      hosts => ["${ES_HOSTS:elasticsearch:9200}"]
      index => "apollo-security-%{+YYYY.MM.dd}"
    }
  }

  # High priority alerts to dedicated channel
  if "high_priority" in [tags] or "target_match" in [tags] {
    http {
      url => "${ALERT_WEBHOOK_URL:http://alertmanager:9093/api/v1/alerts}"
      http_method => "post"
      format => "json"
      mapping => {
        "labels" => {
          "alertname" => "LogBasedAlert"
          "severity" => "critical"
          "service" => "%{service}"
        }
        "annotations" => {
          "summary" => "%{log_message}"
        }
      }
    }
  }

  # Debug output (disable in production)
  if "${DEBUG_LOGS:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
}
